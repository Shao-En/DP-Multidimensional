思考:
1.DP
我們創建了一個二維動態規劃數組 dp，其中 dp[i][j] 表示將 word1 的前 i 個字符轉換成 word2 的前 j 個字符所需的最小操作次數。

我們初始化動態規劃數組的第一行和第一列，考慮將一個字符串轉換成空字串所需的操作次數。

接下來，我們使用雙重迴圈來填充動態規劃數組。在填充的過程中，我們根據 word1 和 word2 的當前字符是否相等進行不同的處理：

如果當前字符相等，則 dp[i][j] 可以繼承 dp[i - 1][j - 1] 的操作次數，因為不需要額外的操作。
如果當前字符不相等，則 dp[i][j] 取 dp[i - 1][j - 1]（替換操作）、dp[i][j - 1]（插入操作）和 dp[i - 1][j]（刪除操作）中的最小值，然後加一，表示進行一次操作。
迴圈結束後，dp[m][n] 將包含將 word1 轉換成 word2 所需的最小操作次數，將其作為函式的回傳結果。

總結來說，這個程式碼使用動態規劃的方法，通過填充二維數組來計算將一個字符串轉換成另一個字符串所需的最小操作次數。這個算法可以解決類似於編輯距離的問題。
```
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();  // 取得 word1 的長度
        int n = word2.size();  // 取得 word2 的長度
        
        // 創建一個二維動態規劃數組，dp[i][j] 表示將 word1 的前 i 個字符轉換成 word2 的前 j 個字符所需的最小操作次數
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        // 初始化第一行和第一列
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;  // 將 word1 的前 i 個字符轉換成空字串，需要 i 次刪除操作
        }
        for (int j = 1; j <= n; j++) {
            dp[0][j] = j;  // 將空字串轉換成 word2 的前 j 個字符，需要 j 次插入操作
        }
        
        // 填充動態規劃數組
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];  // 字符相等，不需要操作，繼承之前的操作次數
                } else {
                    // 字符不相等，選擇三種操作（刪除、插入、替換）中的最小值，並加一
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;
                }
            }
        }
        
        return dp[m][n];  // 返回將 word1 轉換成 word2 所需的最小操作次數
    }
};

```